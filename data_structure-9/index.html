<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>数据结构学习(九) - Sukun&#39;s blog</title><meta name="keywords" content="sukun,hugo,博客">

<meta name="Description" content="数据结构——用C语言描述。本节讲述数据结构技术中的排序。"><meta property="og:title" content="数据结构学习(九)" />
<meta property="og:description" content="数据结构——用C语言描述。本节讲述数据结构技术中的排序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sukun.xyz/data_structure-9/" /><meta property="og:image" content="https://www.sukun.xyz/images/avatar.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-19T11:06:23+08:00" />
<meta property="article:modified_time" content="2022-02-19T11:06:23+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.sukun.xyz/images/avatar.png"/>

<meta name="twitter:title" content="数据结构学习(九)"/>
<meta name="twitter:description" content="数据结构——用C语言描述。本节讲述数据结构技术中的排序。"/>
<meta name="application-name" content="Sukun&#39;">
<meta name="apple-mobile-web-app-title" content="Sukun&#39;"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.sukun.xyz/data_structure-9/" /><link rel="prev" href="https://www.sukun.xyz/qinglong/" /><link rel="next" href="https://www.sukun.xyz/%E6%9C%AC%E5%9C%B0%E5%AE%9A%E6%97%B6%E8%84%9A%E6%9C%AC/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><meta name="baidu-site-verification" content="code-HclBWphrqW" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "数据结构学习(九)",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.sukun.xyz\/data_structure-9\/"
        },"image": ["https:\/\/www.sukun.xyz\/images\/avatar.png"],"genre": "posts","keywords": "数据结构, 学习","wordcount":  6772 ,
        "url": "https:\/\/www.sukun.xyz\/data_structure-9\/","datePublished": "2022-02-19T11:06:23+08:00","dateModified": "2022-02-19T11:06:23+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "sukun","logo": "https:\/\/www.sukun.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Sukun"
            },"description": "数据结构——用C语言描述。本节讲述数据结构技术中的排序。"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <a href="https://github.com/14772" class="github-corner" target="_blank" title="Follow me on GitHub"
            aria-label="Follow me on GitHub"><svg width="3.5rem" height="3.5rem" viewBox="0 0 250 250"
                style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);"
                aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path
                    d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                    fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path
                    d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                    fill="currentColor" class="octo-body"></path>
            </svg></a>
        <div class="header-title">
            <a href="/" title="Sukun&#39;s blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Sukun</a>
        </div>
        <div class="menu">
            <div class="menu-inner">
                <div class="dropdown">
                    <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                        title="归档" ><i class='fas fa-fw fa-archive'></i> 归档 
                    </a>
                    <div class="menu-more-content dropdown-content"><a href="/categories/" title="类别" >	<i class='fa fa-list'></i> 类别 </a><a href="/tags/" title="标签" ><i class='fa fa-tags'></i> 标签 </a><a href="/posts/" title="所有文章" >	<i class='fa fa-folder-open'></i> 所有文章 </a></div>
                </div>
                
                <div class="dropdown">
                    <a href="/"  class="menu-item menu-more dropbtn"
                        title="回到首页" ><i class='fas fa-fw fa-atom'></i> 站点 
                    </a>
                    <div class="menu-more-content dropdown-content"><a href="/bbs/%E5%85%AC%E5%91%8A%E7%95%99%E8%A8%80/" title="公告板&amp;留言板" ><i class='fa fa-comments'></i> 公告留言 </a><a href="/logs/" title="站点日志" ><i class='fas fa-fw fa-cog fa-spin'></i> 站点日志 </a><a href="/about/" title="关于" >	<i class='fa fa-info-circle'></i> 关于 </a></div>
                </div>
                
                <div class="dropdown">
                    <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                        title="文档" ><i class='fas fa-fw fa-book'></i> 文档 
                    </a>
                    <div class="menu-more-content dropdown-content"><a href="https://hugoloveit.com/zh-cn/" title="LoveIt主题文档" > LoveIt主题文档 </a><a href="https://gohugo.io/getting-started/" title="Hugo官方文档" > Hugo官方文档 </a></div>
                </div>
                <a class="menu-item"
                    href="/friends/"  title="欢迎大家来加友链呀" ><i class='fa fa-link fa-fw'></i> 友链墙 
                </a>
                <div class="dropdown">
                    <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                        title="" ><i class='fas fa-fw fa-fan fa-spin'></i> 小游戏 
                    </a>
                    <div class="menu-more-content dropdown-content"><a href="/games/mikutap/" title="来和初音打碟！" ><i class='fa fa-headphones'></i> mikutap </a><a href="/games/catch-the-cat/" title="一起来抓猫！" ><i class='fas fa-fw fa-cat'></i> catch the cat </a></div>
                </div>
                <a class="menu-item"
                    href="/search/"  title="搜索请耐心等待几秒钟" ><i class='fas fa-fw fa-search'></i> 搜索 
                </a><a class="menu-item"
                    href="https://github.com/14772"  title="GitHub"  rel="noopener noreffer"
                    target="_blank" ><i class='fab fa-fw fa-github'></i>  
                </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Sukun&#39;s blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Sukun</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile">
        <div class="dropdown">
            <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                title="归档" ><i class='fas fa-fw fa-archive'></i> 归档 
            </a>
            <div class="menu-more-content dropdown-content"><a href="/categories/" title="类别" >	<i class='fa fa-list'></i> 类别 </a><a href="/tags/" title="标签" ><i class='fa fa-tags'></i> 标签 </a><a href="/posts/" title="所有文章" >	<i class='fa fa-folder-open'></i> 所有文章 </a></div>
        </div>
        
        <div class="dropdown">
            <a href="/"  class="menu-item menu-more dropbtn"
                title="回到首页" ><i class='fas fa-fw fa-atom'></i> 站点 
            </a>
            <div class="menu-more-content dropdown-content"><a href="/bbs/%E5%85%AC%E5%91%8A%E7%95%99%E8%A8%80/" title="公告板&amp;留言板" ><i class='fa fa-comments'></i> 公告留言 </a><a href="/logs/" title="站点日志" ><i class='fas fa-fw fa-cog fa-spin'></i> 站点日志 </a><a href="/about/" title="关于" >	<i class='fa fa-info-circle'></i> 关于 </a></div>
        </div>
        
        <div class="dropdown">
            <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                title="文档" ><i class='fas fa-fw fa-book'></i> 文档 
            </a>
            <div class="menu-more-content dropdown-content"><a href="https://hugoloveit.com/zh-cn/" title="LoveIt主题文档" > LoveIt主题文档 </a><a href="https://gohugo.io/getting-started/" title="Hugo官方文档" > Hugo官方文档 </a></div>
        </div>
        <a class="menu-item"
            href="/friends/"  title="欢迎大家来加友链呀" ><i class='fa fa-link fa-fw'></i> 友链墙 
        </a>
        <div class="dropdown">
            <a href="javascript:void(0);"  class="menu-item menu-more dropbtn"
                title="" ><i class='fas fa-fw fa-fan fa-spin'></i> 小游戏 
            </a>
            <div class="menu-more-content dropdown-content"><a href="/games/mikutap/" title="来和初音打碟！" ><i class='fa fa-headphones'></i> mikutap </a><a href="/games/catch-the-cat/" title="一起来抓猫！" ><i class='fas fa-fw fa-cat'></i> catch the cat </a></div>
        </div>
        <a class="menu-item"
            href="/search/"  title="搜索请耐心等待几秒钟" ><i class='fas fa-fw fa-search'></i> 搜索 
        </a><a class="menu-item"
            href="https://github.com/14772"  title="GitHub"  rel="noopener noreffer"
            target="_blank" ><i class='fab fa-fw fa-github'></i>  
        </a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container">
                    <div class="toc" id="toc-auto">
    <h2 class="toc-title">目录</h2>
    <div class="toc-content" id="toc-content-auto"></div>
</div><article class="page single"><h1 class="single-title animated flipInX">数据结构学习(九)</h1><div class="post-meta">
        <div class="post-meta-line"><span class="post-author"><a href="https://www.sukun.xyz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Sukun</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="far fa-folder fa-fw"></i>算法与数据结构</a></span></div>
        <div class="post-meta-line"><i class="far fa-calendar fa-fw"></i>&nbsp;<time datetime="2022-02-19">2022-02-19</time>&nbsp;<i class="far fa-calendar-plus fa-fw"></i>&nbsp;<time datetime="2022-02-19">2022-02-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6772 字
            <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;<span id="/data_structure-9/" class="leancloud_visitors" data-flag-title="数据结构学习(九)">
                <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
            </span>&nbsp;
            <a href="#comments" id="post-meta-vcount" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>&nbsp;<span id="/data_structure-9/"
                    class="waline-comment-count"></span>&nbsp;条评论
            </a></div>

    </div><div class="details toc" id="toc-static" kept="">
        <div class="details-summary toc-title">
            <span>目录</span>
            <span><i class="details-icon fas fa-angle-right"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#技术">技术</a>
      <ul>
        <li><a href="#排序">排序</a>
          <ul>
            <li><a href="#内部排序">内部排序</a>
              <ul>
                <li><a href="#排序的基本概念">排序的基本概念</a>
                  <ul>
                    <li><a href="#排序-1">排序</a></li>
                    <li><a href="#内部排序与外部排序">内部排序与外部排序</a></li>
                    <li><a href="#排序的稳定性">排序的稳定性</a></li>
                    <li><a href="#基本操作">基本操作</a></li>
                    <li><a href="#存储方法">存储方法</a></li>
                  </ul>
                </li>
                <li><a href="#插入类排序">插入类排序</a>
                  <ul>
                    <li><a href="#插入排序基本思想">插入排序基本思想</a></li>
                    <li><a href="#直接插入排序">直接插入排序</a></li>
                    <li><a href="#折半排序">折半排序</a></li>
                    <li><a href="#希尔排序缩小增量排序">希尔排序（缩小增量排序）</a></li>
                  </ul>
                </li>
                <li><a href="#交换类排序">交换类排序</a>
                  <ul>
                    <li><a href="#交换排序基本思想">交换排序基本思想</a></li>
                    <li><a href="#冒泡排序相邻比序法">冒泡排序（相邻比序法）</a></li>
                    <li><a href="#快速排序">快速排序</a></li>
                  </ul>
                </li>
                <li><a href="#选择类排序">选择类排序</a>
                  <ul>
                    <li><a href="#选择排序基本思想">选择排序基本思想</a></li>
                    <li><a href="#简单选择排序">简单选择排序</a></li>
                    <li><a href="#树形选择排序">树形选择排序</a></li>
                    <li><a href="#堆排序">堆排序</a></li>
                  </ul>
                </li>
                <li><a href="#归并类排序">归并类排序</a>
                  <ul>
                    <li><a href="#基本思想">基本思想</a></li>
                    <li><a href="#算法描述">算法描述</a></li>
                    <li><a href="#算法分析">算法分析</a></li>
                  </ul>
                </li>
                <li><a href="#分配类排序">分配类排序</a>
                  <ul>
                    <li><a href="#多关键字排序">多关键字排序</a></li>
                    <li><a href="#链式基数排序">链式基数排序</a></li>
                    <li><a href="#基数排序的顺序表实现">基数排序的顺序表实现</a></li>
                  </ul>
                </li>
                <li><a href="#比较">比较</a>
                  <ul>
                    <li><a href="#性能比较">性能比较</a></li>
                    <li><a href="#稳定性比较">稳定性比较</a></li>
                  </ul>
                </li>
                <li><a href="#结论">结论</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div><div class="content" id="content"><h1 id="数据结构用c语言描述九">数据结构——用C语言描述(九)</h1>
<h2 id="技术">技术</h2>
<h3 id="排序">排序</h3>
<h4 id="内部排序">内部排序</h4>
<h5 id="排序的基本概念">排序的基本概念</h5>
<h6 id="排序-1">排序</h6>
<p>记录序列：{$R_1,R_2,&hellip;,R_n$}</p>
<p>关键字序列：{$K_1,K_2,&hellip;,K_n$}</p>
<p>重排记录序列，得{$Rp_1,Rp_2,&hellip;,Rp_n$}，使相应关键字满足非递减（或非递增）关系，</p>
<p>即$Kp_1≤Kp_2≤&hellip;≤Kp_n$</p>
<h6 id="内部排序与外部排序">内部排序与外部排序</h6>
<p>根据排序时数据所占用<strong>存储器</strong>的不同，可将排序分为两类：</p>
<ul>
<li>内部排序：整个排序过程完全在内存中进行</li>
<li>外部排序：由于待排序数据量太大，内存无法容纳全部数据，排序需借外存才能完成</li>
</ul>
<h6 id="排序的稳定性">排序的稳定性</h6>
<ul>
<li>稳定排序：在排序过程中，相同关键字（$K_i=K_j$,i&lt;j）其领先关系不发生变化——需从算法本身步骤中证明</li>
<li>不稳定排序：在排序过程中，相同关键字（$K_i=K_j$,i&lt;j）其领先关系发生变化——仅需举反例即可证明不稳定</li>
</ul>
<h6 id="基本操作">基本操作</h6>
<ol>
<li><strong>比较</strong>两个关键字的大小</li>
<li>将记录从一个位置<strong>移动</strong>到另一个位置</li>
</ol>
<h6 id="存储方法">存储方法</h6>
<ol>
<li>
<p><strong>向量结构</strong>：</p>
<p>将待排序的记录存放在一组地址连续的存储单元中</p>
</li>
<li>
<p>链表结构</p>
</li>
<li>
<p>地址排序</p>
</li>
</ol>
<h5 id="插入类排序">插入类排序</h5>
<h6 id="插入排序基本思想">插入排序基本思想</h6>
<p>已排序记录子集基础上，将下一个待排序记录<strong>有序插入</strong>到已排序记录子集，直到将所有待排序记录全部插入。</p>
<h6 id="直接插入排序">直接插入排序</h6>
<ul>
<li>
<p>算法思想：将第 i 个插入到前 i-1 个有序集合。</p>
</li>
<li>
<p>算法要点：</p>
<ol>
<li>监视哨<code>r[0]</code>保存待插入的记录</li>
<li>方向从后往前查找插入位置</li>
<li>查找与移动用同一循环完成</li>
</ol>
</li>
<li>
<p>算法实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">InsSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="c1">//对记录数组r做直接插入排序, length为数组的长度
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//将待插入记录存放到监视哨r[0]中
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="c1">//寻找插入位置
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//将待插入记录插入已排序的序列中}
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<ul>
<li>
<p>最好情况：</p>
<p>有序的待排序序列——比较次数 n-1 次，移动次数 2(n-1) 次</p>
</li>
<li>
<p>最坏情况：</p>
<p>待排序记录为逆序排列——总比较次数：
$$
\sum_{i=2}^ni=\frac{(n+2)(n-1)}{2}
$$
记录移动次数：
$$
\sum_{i=2}^n(i+1)=\frac{(n+4)(n-1)}{2}
$$
故直接插入排序的时间复杂度为$T(n)=O(n^2)$</p>
</li>
<li>
<p>直接插入排序是稳定排序：</p>
<p>从后向前进行算法<code>while(r[0].key&lt;r[j] key)</code>相同元素插入到<code>r[j+1]</code></p>
</li>
</ul>
</li>
</ul>
<h6 id="折半排序">折半排序</h6>
<ul>
<li>
<p>算法改进要点：改进确定插入位置方法</p>
</li>
<li>
<p>算法描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">BinSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="c1">//对数组r进行折半插入排序，length为数组长度
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">mid</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="c1">//确定插入位置
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">low</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">//记录依次向后移动
</span><span class="c1"></span>        <span class="n">r</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">//插入记录
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<p>折半插入可减少关键字的比较次数，但移动次数没有减少，故折半插入排序的总的时间复杂度仍然是$O(n^2)$。</p>
<p>每插入一个元素，最大的比较次数为折半判定树的深度。</p>
<p>插入第 i 个元素，设$i=2^j$，则需进行$\log_2i$次比较，插入 n-1 个元素的平均关键字的比较次数为$O(n\log_2n)$</p>
<p>折半排序是稳定排序：待插入元素 x 位于有序序列之后，经过条件比较，元素相等时，其插入位置<code>low=mid+1</code>右部子表</p>
</li>
</ul>
<h6 id="希尔排序缩小增量排序">希尔排序（缩小增量排序）</h6>
<ul>
<li>
<p>算法改进要点：</p>
<p>利用直接插入排序的最佳性质：n 比较小、基本有序。</p>
<ol>
<li>将记录序列分成若干个子序列分别进行直接插入排序</li>
<li>经多次调整序列记录已基本有序最后再对记录进行直接插入排序</li>
</ol>
</li>
<li>
<p>算法思想：</p>
<ol>
<li>对整个文件，按间隔$d_1$分组，组内排序</li>
<li>取$d_2&lt;d_1$（缩小增量），继续以$d_2$为距离排序，直到$d_t=1$（同直接插入排序）为止</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://s2.loli.net/2022/02/19/zGKfOStQIvcVLrj.png"
        data-srcset="https://s2.loli.net/2022/02/19/zGKfOStQIvcVLrj.png, https://s2.loli.net/2022/02/19/zGKfOStQIvcVLrj.png 1.5x, https://s2.loli.net/2022/02/19/zGKfOStQIvcVLrj.png 2x"
        data-sizes="auto"
        alt="https://s2.loli.net/2022/02/19/zGKfOStQIvcVLrj.png"
        title="image-20220219115543161" /></p>
</li>
<li>
<p>算法描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">ShellInsert</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="c1">//对记录数组r做一趟希尔插入排序，length为数组长度，delta为增量
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 1+delta为第一个子序列的第二个元素的下标
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delta</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//备份r[i]（不做监视哨）
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">)</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="c1">//对记录数组r做希尔排序，length为数组r长度，delta为增量数组，n为delta[]的长度
</span><span class="c1"></span><span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ShellInsert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>逆转数是指在此关键字之前比它大的数据个数</p>
<table>
<thead>
<tr>
<th>待排序序列</th>
<th>46</th>
<th>55</th>
<th>13</th>
<th>42</th>
<th>94</th>
<th>17</th>
<th>05</th>
<th>90</th>
</tr>
</thead>
<tbody>
<tr>
<td>逆转数$B_i$</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>4</td>
<td>6</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
        </div>
    </div>
<ul>
<li>
<p>希尔排序比直接插入排序更快：</p>
<p>直接插入排序：一次比较移动只减少一个逆转数</p>
<p>希尔排序：一次比较移动减少逆转数有可能不止一个</p>
</li>
<li>
<p>根据经验公式可给出缩小增量的取法：</p>
<p>Shell 提出$d=\frac{n}{2}$，$d=\frac{d}{2}$，直到 d=1为止</p>
<p>奇数位置元素在最后一趟才会与偶数位置比较，效率较低</p>
<p>knuth 提出$d=\frac{d}{3}+1$</p>
</li>
<li>
<p>希尔排序时间复杂度为$O(n^{\frac{3}{2}})$</p>
</li>
<li>
<p>希尔排序是不稳定排序：</p>
<p>例如待排序列 {2,4,1,2}，进行希尔排序后变为 {1,2,2,4}，其中相同关键字 2 的领先关系发生了变化。</p>
</li>
</ul>
</li>
</ul>
<h5 id="交换类排序">交换类排序</h5>
<h6 id="交换排序基本思想">交换排序基本思想</h6>
<p>通过一系列交换逆序元素进行排序</p>
<h6 id="冒泡排序相邻比序法">冒泡排序（相邻比序法）</h6>
<ul>
<li>
<p>算法思想</p>
<p>顺次比较相邻两元素大小，若逆序就交换位置，反复扫描，直到待排序记录没有逆序为止。</p>
</li>
<li>
<p>算法描述</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">BubbSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="c1">//冒泡排序
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">change</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">change</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">change</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<p>最坏情况——关键字逆序排列，第 i 趟需 n-i 次比较，3(n-i) 次移动经过 n-1 趟冒泡排序：</p>
<ul>
<li>比较次数$\frac{n(n-1)}{2}$</li>
<li>移动次数$\frac{3n(n-1)}{2}$</li>
<li>时间复杂度$O(n^2)$</li>
<li>空间复杂度$O(1)$</li>
</ul>
</li>
</ul>
<h6 id="快速排序">快速排序</h6>
<ul>
<li>
<p>改进要点：</p>
<p>通过两个不相邻元素的比较，一次交换可能消除多个逆序，大大加快排序速度。</p>
</li>
<li>
<p>算法思想：</p>
<p>选序列中一个枢轴元（选第 1 个其关键字$K_1$）以枢轴元素为界，分为两个子表小于$K_1$在前部子表，大于$K_1$在后部子表，对两个子表继续如上过程，直到所有子表的表长不超过 1 为止。</p>
</li>
<li>
<p>算法描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">QKPass</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="c1">//一趟排序
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">[</span><span class="n">high</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">high</span><span class="o">--</span><span class="p">;</span> <span class="c1">//从右到左找小于x.key的记录
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">high</span><span class="p">];</span>
            <span class="n">low</span><span class="o">++</span><span class="p">;</span> <span class="c1">//置入左r[low]
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">[</span><span class="n">low</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">low</span><span class="o">++</span><span class="p">;</span> <span class="c1">//从左到右找大于x.key的记录
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">high</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
            <span class="n">high</span><span class="o">--</span><span class="p">;</span> <span class="c1">//置入右r[high]
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">r</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">low</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">QKSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="c1">//快速排序
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">QKPass</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span> <span class="c1">//枢轴位置
</span><span class="c1"></span>        <span class="n">QKSort</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">//前部子表
</span><span class="c1"></span>        <span class="n">QKSort</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>   <span class="c1">//后部子表
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<ul>
<li>
<p>最好情况：</p>
<p>每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，类似折半查找</p>
<p>时间复杂度$O(n\log_2n)$</p>
</li>
<li>
<p>最坏情况：</p>
<p>已经排好序共需进行 n- 1 趟排序,其比较次数为：
$$
\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}
$$
时间复杂度$O(n^2)$</p>
</li>
<li>
<p>平均时间复杂度：$T_{avg}(n)=n\log_2n$</p>
</li>
</ul>
</li>
</ul>
<h5 id="选择类排序">选择类排序</h5>
<h6 id="选择排序基本思想">选择排序基本思想</h6>
<p>每一趟在 n-i+1 (i=1,2,…n-1) 个记录中选取关键字最小的记录作为有序序列中第 i 个记录</p>
<h6 id="简单选择排序">简单选择排序</h6>
<ul>
<li>
<p>算法思想：第 i 趟排序从 n-i+1 个记录中选出关键字最小的记录，并和第 i 个元素进行交换</p>
</li>
<li>
<p>算法描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//对记录数组r做简单选择排序，n为数组长度
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<ul>
<li>
<p>最好情况：</p>
<p>待排序记录初始状态就已经是正序排列了，则不需要移动记录</p>
</li>
<li>
<p>最坏情况：</p>
<p>待排序记录初始状态是按逆序排列的，则需要移动记录的次数最多为 3(n-1)</p>
</li>
<li>
<p>时间复杂度：</p>
<p>由于每次都没有利用上次比较的结果，故时间复杂度为$O(n^2)$</p>
</li>
<li>
<p>简单选择排序是不稳定排序：</p>
<p>例如，待排序列 {3,3,2} 经过简单选择排序变为 {2,3,3}，相同关键字 3 的领先关系发生了变化</p>
</li>
</ul>
</li>
</ul>
<h6 id="树形选择排序">树形选择排序</h6>
<ul>
<li>
<p>算法改进要点：</p>
<p>把比较过程中的大小关系保存下来以降低比较次数</p>
</li>
<li>
<p>基本思想：</p>
<ol>
<li>
<p>把待排序的 n 个记录的关键字两两进行比较，取出较小者</p>
</li>
<li>
<p>在$[\frac{n}{2}]$个较小者中，采用同样的方法进行比较选出每两个中的较小者。如此反复，直至选出最小关键字记录为止</p>
</li>
</ol>
</li>
<li>
<p>算法分析：</p>
<p>每趟选出较小关键字需$\log_2n$次比较，n 趟比较时间复杂度$O(n\log_2n)$</p>
<p>移动记录次数不超过比较次数。</p>
<p>总的时间复杂度为$O(n\log_2n)$。</p>
<p>与简单选择排序相比较，其降低了比较次数的数量级，增加了 n-1个非叶子节点的辅助存储空间也就是以空间换时间。</p>
</li>
</ul>
<h6 id="堆排序">堆排序</h6>
<ul>
<li>
<p>算法改进要点</p>
<p>将待排序数组看成一棵完全二叉树，结点<code>r[i]</code>的左孩子是<code>r[2i]</code>，右孩子<code>r[2i+1]</code>，双亲是<code>r[i/2]</code>。</p>
<p>通过调整完全二叉树建堆及重建堆选择出关键字最小记录及次小记录等实现排序。</p>
</li>
<li>
<p>算法思想</p>
<ul>
<li>
<p>堆</p>
<p>将待排序数组 r 看成一棵完全二叉树的顺序表示，对二叉树进行调整，满足下列条件为堆：</p>
<p>$r[i].key≥r[2i].key$并且$r[i].key≥r[2i+1].key$ (i=1,2,…)</p>
<p>或者$r[i].key≤r[2i].key$并且$r[i].key≤r[2i+1].key$ (i=1,2,…)</p>
</li>
<li>
<p>大根堆：完全二叉树中任意节点的关键字大于或等于其左孩子和右孩子的关键字</p>
</li>
<li>
<p>小根堆：完全二叉树中任意节点的关键字小于或等于其左孩子和右孩子的关键字</p>
</li>
</ul>
</li>
<li>
<p>堆排序问题</p>
<p>以大根堆为例</p>
<ol>
<li>
<p>按堆定义建初堆</p>
</li>
<li>
<p>去掉最大元之后重建堆，得到次大元</p>
</li>
<li>
<p>如此类推</p>
</li>
</ol>
<ul>
<li>
<p>重建堆：当堆顶记录改变时，如何重建堆？</p>
<ol>
<li>
<p>将完全二叉树根结点中关键字 x 移出，此时根结点相当于空结点</p>
</li>
<li>
<p>从左、右孩子中选出关键字最大的记录,如果该记录的关键字大于 x，则将该记录上移至空结点</p>
</li>
<li>
<p>重复上述过程，直到空结点左、右孩子关键字均不大于 x，此时，将待调整记录 x 放入空结点即可</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//重建堆，r[k..m]是以r[k]为根的完全二叉树，其左右子树为大根堆
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sift</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RecordType</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">KeyType</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">finished</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="c1">//暂存根记录r[k]
</span><span class="c1"></span>    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">finished</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="c1">//若存在右子树且根的关键字大则沿右分支筛选
</span><span class="c1"></span>            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="c1">//筛选完备
</span><span class="c1"></span>            <span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="c1">//继续筛选
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// r[k]填入到恰当位置
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>建初堆：如何由一个任意序列建初堆？</p>
<p>筛选需从最后一个子树位置$\lfloor\frac{n}{2}\rfloor$开始，可以反复利用重建堆法自底向上，把所有的子树逐层调整为堆，直至根结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//对记录数组r重建堆，length为数组长度
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">crt_heap</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="c1">//自第i个记录开始筛选建堆
</span><span class="c1"></span>        <span class="n">sift</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>堆排序算法：</p>
<ol>
<li>建初堆：从最后一子树$\frac{n}{2}$直到根建堆</li>
<li>将（堆顶）第一个元素与最后一个元素互换;去掉最后元素，将剩余元素调整建堆，再转出堆顶元素</li>
<li>重复执行步骤 2、3 共 n-1 次，直到序列有序</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//对r[1..n]堆排序，关键字由大到小排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">crt_heap</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span> <span class="c1">//建初堆
</span><span class="c1"></span>    <span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="c1">//将堆顶记录和堆的最后一个记录互换
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">sift</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//进行调整，使r[1..i-1]变成堆
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>算法分析：</p>
<ol>
<li>
<p>重建堆的时间复杂度为$O(n\log_2n)$需 n-1 次重建堆</p>
<p>建初堆时间复杂度为$O(n\log_2n)$，堆排序时间复杂度为$O(n\log_2n)$</p>
</li>
<li>
<p>堆排序与树型排序相比较，排序中只需要存放一个记录的辅助空间，因此也将堆排序称作原地排序</p>
</li>
<li>
<p>堆排序是一种<strong>不稳定</strong>的排序方法，它不适用于待排序记录个数 n 较少的情况，但对 n 较大的文件还是很有效的</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://s2.loli.net/2022/02/19/7A46HGEzmcXj5t3.png"
        data-srcset="https://s2.loli.net/2022/02/19/7A46HGEzmcXj5t3.png, https://s2.loli.net/2022/02/19/7A46HGEzmcXj5t3.png 1.5x, https://s2.loli.net/2022/02/19/7A46HGEzmcXj5t3.png 2x"
        data-sizes="auto"
        alt="https://s2.loli.net/2022/02/19/7A46HGEzmcXj5t3.png"
        title="image-20220219224827278" /></p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>选择类排序比较</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单选择</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>树型选择</td>
<td>$O(n\log_2n)$</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(1)$</td>
</tr>
</tbody>
</table>
<h5 id="归并类排序">归并类排序</h5>
<h6 id="基本思想">基本思想</h6>
<p>基于合并的思想，将两个或两个以上有序表合并成一个新的有序表。</p>
<p>2-路归并排序：</p>
<ol>
<li>初始：n 个记录看成 n 个长度为 1 的有序子序列</li>
<li>两两归并得$\lfloor\frac{n}{2}\rfloor$个长度为 2 的有序子序列</li>
<li>两两归并得到若干个长度为 4 的有序子序列 i</li>
<li>如此重复，直到得到长度为n的有序序列为止</li>
</ol>
<h6 id="算法描述">算法描述</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//初始调用，对数组r[1..n]做归并排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MSort</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//一趟合并算法
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="n">RecordType</span> <span class="n">r</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">))</span> <span class="c1">//对序列的前后两半部分进行比较
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r1</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">r1</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="c1">//合并两个子序列
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// r1[low..high]归并排序后放入r3[low..high]
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MSort</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">r1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="n">RecordType</span> <span class="n">r3</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
    <span class="n">RecordType</span> <span class="n">r2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">//辅助空间
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">r3</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>       <span class="c1">//前半部分归并
</span><span class="c1"></span>        <span class="n">MSort</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>  <span class="c1">//后半部分归并
</span><span class="c1"></span>        <span class="n">Merge</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">r3</span><span class="p">);</span> <span class="c1">// r2合并放入r3
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="算法分析">算法分析</h6>
<ul>
<li>
<p>一趟归并排序的时间复杂度为$O(n)$，将<code>r1[1..n]</code>前后两个有序子表归并后并存放到<code>r2[1..n]</code>中</p>
</li>
<li>
<p>归并排序的时间复杂度为$O(n\log_2n)$，整个归并排序进行$\log_2n$趟2-路归并，每趟归并是$O(n)$</p>
</li>
<li>
<p>归并排序的空间复杂度为$O(n)$，归并排序需用到与待排序序列等量的辅助空间<code>r2[n]</code></p>
<p>这也使归并排序适合于外部排序：</p>
<ul>
<li>归并路数取决于外部设备的台数</li>
<li>归并长度取决于内存缓冲区的容量</li>
<li>支持外存分批并行调入内存，提高效率</li>
</ul>
</li>
<li>
<p>归并排序是稳定排序：</p>
<p>在一趟归并算法中，前部相同元素先于后部置入归并排序后的表，使其相同关键字的领先关系不发生变化。</p>
</li>
</ul>
<h5 id="分配类排序">分配类排序</h5>
<p>利用基于分配的思想通过分配和叫收集两种操作实现排序。</p>
<h6 id="多关键字排序">多关键字排序</h6>
<ul>
<li>高位优先排序法</li>
<li>低位优先排序法</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">字典就是采用的多关键字排序</div>
        </div>
    </div>
<h6 id="链式基数排序">链式基数排序</h6>
<ul>
<li>
<p>存储结构：用链表存储待排序表</p>
</li>
<li>
<p>排序思想：多趟分配和收集完成排序（趟数为关键字位数）</p>
</li>
<li>
<p>基数 RD：关键字符号的个数（十进制的基数为 0~9）</p>
</li>
<li>
<p>算法思想：</p>
<p>按最低位的值对记录进行初步排序，在此基础上按次低位的值进行进一步排序，按由低向高，直到最高位，关键字的每一位都排序。</p>
</li>
<li>
<p>算法描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define RADIX 10
</span><span class="cp">#define KEY_SIZE 6
</span><span class="cp">#define LIST_SIZE 20
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">KeyType</span> <span class="n">key</span><span class="p">[</span><span class="n">KEY_SIZE</span><span class="p">];</span> <span class="c1">//子关键字数组
</span><span class="c1"></span>    <span class="n">OtherType</span> <span class="n">other_data</span><span class="p">;</span>  <span class="c1">//其他数据项
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>              <span class="c1">//静态链域
</span><span class="c1"></span><span class="p">}</span> <span class="n">RecordType1</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">RecordType1</span> <span class="n">r</span><span class="p">[</span><span class="n">LIST_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// r[0]为头结点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">keynum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SLinkList</span><span class="p">;</span> <span class="c1">//静态链表
</span><span class="c1"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">PVector</span><span class="p">[</span><span class="n">RADIX</span><span class="p">];</span>
<span class="n">PVector</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">RadixSort</span><span class="p">(</span><span class="n">RecordType1</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keynum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//构造动态链表
</span><span class="c1"></span>        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">keynum</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="c1">//从最低位子关键字开始，进行d趟分配收集
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">Distribute</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span> <span class="c1">//第i趟分配
</span><span class="c1"></span>        <span class="n">Collect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>       <span class="c1">//第i趟收集
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Distribute</span><span class="p">(</span><span class="n">RecordType1</span> <span class="n">r</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">PVector</span> <span class="n">head</span><span class="p">,</span> <span class="n">PVector</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">RADIX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// RADIX个队列初始化为空
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">//用第i位关键字求相应队列号
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//将p结点插入第j个队列
</span><span class="c1"></span>        <span class="k">else</span>
            <span class="n">r</span><span class="p">[</span><span class="n">tail</span><span class="p">[</span><span class="n">j</span><span class="p">]].</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">tail</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Collect</span><span class="p">(</span><span class="n">RecordType1</span> <span class="n">r</span><span class="p">[],</span> <span class="n">PVector</span> <span class="n">head</span><span class="p">,</span> <span class="n">PVector</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="c1">//找第一个非空队列
</span><span class="c1"></span>        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">RADIX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">//寻找并串接所有非空队列
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">RADIX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>     <span class="c1">//找下个非空队列
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="c1">//链接非空队列
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">r</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">r</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法分析：</p>
<ul>
<li>n 个记录（每记录含 d 位,每位取值 RD 个值）</li>
<li>一趟分配算法的时间复杂度为$O(n)$</li>
<li>一趟收集算法的时间复杂度为$O(RD)$</li>
<li>共进行 d 趟分配与收集，总时间复杂度为$O(d(n+RD))$</li>
<li>辅助空间为$O(RD)$</li>
</ul>
</li>
</ul>
<h6 id="基数排序的顺序表实现">基数排序的顺序表实现</h6>
<p>按照稀疏矩阵转置中的统计方法实现</p>
<p>例：待排序序列218，109，063，930，589，184，505，269，008，083</p>
<p>关键字$k_1、k_2、k_3$，$k_3$位扫描，统计$k_3$位为 0 到 9 的记录个数<code>num[10]</code></p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>num[]</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>cpos[]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>$k_3$位上值为 i 的记录在排好序向量中第一次出现位置<code>cpos[i]</code>，由<code>cpos[0]=0</code>可确定<code>cpos[i]=cpos[i-1]+num[i-1]</code>，完成按$k_3$位进行的排序。</p>
<p>$k_2$和$k_1$位以此类推，分别统计、定位与置放，完成基数排序。</p>
<h5 id="比较">比较</h5>
<h6 id="性能比较">性能比较</h6>
<table>
<thead>
<tr>
<th></th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>辅助存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(n\log_2n)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(n\log_2n)$</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(d(n+RD))$</td>
<td>$O(d(n+RD))$</td>
<td>$O(rd)$</td>
</tr>
</tbody>
</table>
<h6 id="稳定性比较">稳定性比较</h6>
<table>
<thead>
<tr>
<th></th>
<th>稳定性</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>简单选择排序</td>
<td>否</td>
<td>(3,3,2)</td>
</tr>
<tr>
<td>希尔排序</td>
<td>否</td>
<td>(2,4,1,2)，$d_1$=2,$d_2$=1</td>
</tr>
<tr>
<td>快速排序</td>
<td>否</td>
<td>(3,2,2)</td>
</tr>
<tr>
<td>堆排序</td>
<td>否</td>
<td>(5,5,3)</td>
</tr>
<tr>
<td>归并排序</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td>是</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="结论">结论</h5>
<ol>
<li><strong>简单排序</strong>一般只用于<strong>n较小</strong>的情况。当序列中的记录<strong>基本有序</strong>时，直接插入排序是最佳的排序方法，其常与其他排序方法组合使用</li>
<li><strong>快速排序</strong>平均时间性能是最好的</li>
<li>堆排序和归并排序的最坏时间复杂度仍为$O(n\log_2n)$，当<strong>n较大</strong>时，<strong>归并排序</strong>的时间性能优于堆排序，但它所需的<strong>辅助空间最多</strong></li>
<li><strong>基数排序</strong>最适用于<strong>n很大</strong>而<strong>关键字的位数d较小</strong>的序列。</li>
</ol></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-02-19</span>
            </div>
            <div class="post-info-license"><span><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" one-link-mark="yes" class="link-instanted">CC BY-NC 4.0</a></span></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/data_structure-9/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>,&nbsp;<a href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/qinglong/" class="prev" rel="prev" title="青龙面板教程"><i class="fas fa-angle-left fa-fw"></i>青龙面板教程</a>
            <a href="/%E6%9C%AC%E5%9C%B0%E5%AE%9A%E6%97%B6%E8%84%9A%E6%9C%AC/" class="next" rel="next" title="本地定时脚本">本地定时脚本<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="waline"></div>
    <script src='https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>

    <script>
        new Waline({
            el: '#waline',
            meta: ["nick","mail","link"],
            requiredMeta: ["nick","mail"],
            login: "force",
            placeholder: "为防恶意灌水攻击，评论前需注册并登录，望见谅~",
            serverURL: "https://blog-api-jade.vercel.app",
            avatarCDN: "https://sdn.geekzu.org/avatar/",
            pageSize:  20 ,
            avatar: "retro",
            lang: "zh-CN",
            visitor:  true ,
            highlight:  true ,
            uploadImage:  false ,
            emoji: [
            'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq',
            'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
            'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
        ],
                		    	});
    </script></div></article></div>
            </main>
            <footer class="footer">
    <div class="footer-container">
        <div class="footer-line">
            <span id="run-time"></span>
        </div><div class="footer-line"><span>本网站由</span><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="blank"><img height="18" src="http://image.sukun.xyz/img/又拍云_logo5.png" alt="又拍云"></a><span>提供 CDN 加速/云存储服务</span></div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a
                    href="https://www.sukun.xyz" target="_blank">Sukun</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" one-link-mark="yes" class="link-instanted">CC BY-NC 4.0</a></span></div>
    </div>
</footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script type="text/javascript">
    window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date());
    gtag('config', 'UA-207270792-1', { 'anonymize_ip': true });
</script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-207270792-1" async></script><script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?36906624de93fc40ef084568363cdc35";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script></body>
</html>
